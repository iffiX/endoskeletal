import numpy as np
from noise import pnoise2


def generate_mountain_terrain(
    x_values: int,
    y_values: int,
    slope: float = 0.1,
    center_radius: float = 3,
    max_height: float = 2,
) -> np.ndarray:
    """
    Generate a funnel like mountain terrain.
    """
    ground = np.zeros((y_values, x_values))
    center_x = x_values // 2
    center_y = y_values // 2
    for x in range(x_values):
        for y in range(y_values):
            dist = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)
            if dist > center_radius:
                ground[y, x] = min(slope * (dist - center_radius), max_height)
    return ground


def generate_noisy_mountain_terrain(
    x_values: int,
    y_values: int,
    slope: float = 0.08,
    center_radius: float = 3,
    noise_amplitude: float = 0.02,
    max_height: float = 1.5,
) -> np.ndarray:
    """
    Generate a noisy, funnel like mountain terrain.
    """
    ground = np.zeros((y_values, x_values))
    center_x = x_values // 2
    center_y = y_values // 2
    for x in range(x_values):
        for y in range(y_values):
            dist = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)
            if dist > center_radius:
                noise = np.random.uniform(-1, 1)
                ground[y, x] = (
                    min(slope * (dist - center_radius), max_height)
                    + noise * noise_amplitude
                )
    return ground


def generate_perlin_noise_ground(
    x_values: int,
    y_values: int,
    octaves: int = 6,
    persistence: float = 0.5,
    lacunarity: float = 2.0,
    seed: int = 42,
) -> np.ndarray:
    """
    Generate a 2D numpy array representing ground using Perlin noise.

    Args:
        x_values (int): The width of the ground (number of columns in the array).
        y_values (int): The height of the ground (number of rows in the array).
        octaves (int, optional): The number of levels of detail in the noise.
            Higher values produce more detailed noise. Defaults to 6.
        persistence (float, optional): The amplitude of each successive octave relative to the previous one.
            Controls how quickly the amplitudes decrease. Defaults to 0.5.
        lacunarity (float, optional): The frequency of each successive octave relative to the previous one.
            Controls how quickly the frequencies increase. Defaults to 2.0.
        seed (int, optional): The seed value for random number generation, ensuring reproducibility of noise.
            Defaults to 42.

    Returns:
        np.ndarray: A 2D numpy array representing the ground, with values generated by Perlin noise.
    """
    ground = np.zeros((y_values, x_values))

    for y in range(y_values):
        for x in range(x_values):
            ground[y][x] = pnoise2(
                x / x_values,
                y / y_values,
                octaves=octaves,
                persistence=persistence,
                lacunarity=lacunarity,
                repeatx=x_values,
                repeaty=y_values,
                base=seed,
            )
    return ground


def generate_wave_ground(
    x_values: int,
    y_values: int,
    trapezoid_base_length: int = 10,
    trapezoid_top_length: int = 5,
    trapezoid_height: float = 0.3,
    x_direction: bool = True,
) -> np.ndarray:
    """
    Generate a wave-like ground with trapezoidal protrusions and trenches in the x or y direction.

    Args:
        x_values (int): The width of the ground (number of columns in the array).
        y_values (int): The height of the ground (number of rows in the array).
        trapezoid_base_length (int, optional): The base length of the trapezoids.
            Controls the distance between the two inclined sides of the trapezoid. Defaults to 10.
        trapezoid_top_length (int, optional): The top length of the trapezoids.
            Controls the flat portion on top of the trapezoid. Defaults to 5.
        trapezoid_height (float, optional): The height of the trapezoids.
            Controls how tall the trapezoids are from base to top. Defaults to 0.3.
        x_direction (bool, optional): If True, the wave is oriented in the x direction.
            If False, the wave is oriented in the y direction. Defaults to True.

    Returns:
        np.ndarray: A 2D numpy array representing the ground, with trapezoid-shaped
        protrusions and trenches in the specified direction.
    """

    # Initialize the ground with zeros
    ground = np.zeros((y_values, x_values))

    # Calculate center of the height to ensure the center is zero
    center_x = x_values // 2

    # Calculate trapezoid properties
    half_base_length = trapezoid_base_length / 2
    half_top_length = trapezoid_top_length / 2

    for x in range(x_values):
        # Calculate the x-offset for wave pattern based on horizontal position (j)
        x_relative = (x - center_x) % trapezoid_base_length
        phase = 1 if ((x - center_x) // trapezoid_base_length) % 2 == 0 else -1

        if x_relative < half_base_length - half_top_length:
            # Sloped side of the trapezoid (ascending)
            ground[:, x] = (
                x_relative / (half_base_length - half_top_length)
            ) * trapezoid_height
        elif x_relative < (half_base_length + half_top_length):
            # Flat top of the trapezoid
            ground[:, x] = trapezoid_height
        else:
            # Sloped side of the trapezoid (descending)
            ground[:, x] = (
                (trapezoid_base_length - x_relative)
                / (half_base_length - half_top_length)
            ) * trapezoid_height

        ground[:, x] *= phase

    if not x_direction:
        ground = ground.T
    return ground


def generate_2d_wave_ground(
    x_values: int,
    y_values: int,
    trapezoid_base_length: int = 10,
    trapezoid_top_length: int = 5,
    trapezoid_height: int = 0.3,
) -> np.ndarray:
    """
    Generate a wave-like ground with trapezoidal protrusions and trenches in the x or y direction.

    Args:
        x_values (int): The width of the ground (number of columns in the array).
        y_values (int): The height of the ground (number of rows in the array).
        trapezoid_base_length (int, optional): The base length of the trapezoids.
            Controls the distance between the two inclined sides of the trapezoid. Defaults to 10.
        trapezoid_top_length (int, optional): The top length of the trapezoids.
            Controls the flat portion on top of the trapezoid. Defaults to 5.
        trapezoid_height (int, optional): The height of the trapezoids.
            Controls how tall the trapezoids are from base to top. Defaults to 5.

    Returns:
        np.ndarray: A 2D numpy array representing the ground, with trapezoid-shaped
        protrusions and trenches in the specified direction.
    """

    # Initialize the ground with zeros
    ground = np.zeros((y_values, x_values))

    # Calculate center of the height to ensure the center is zero
    center_x = x_values // 2
    center_y = y_values // 2

    # Calculate trapezoid properties
    half_base_length = trapezoid_base_length / 2
    half_top_length = trapezoid_top_length / 2

    for x in range(x_values):
        for y in range(y_values):
            # Calculate the x-offset for wave pattern based on horizontal position (j)
            x_relative = (x - center_x) % trapezoid_base_length
            y_relative = (y - center_y) % trapezoid_base_length
            phase = (
                1
                if (
                    ((x - center_x) // trapezoid_base_length) % 2 == 0
                    and ((y - center_y) // trapezoid_base_length) % 2 == 0
                )
                or (
                    ((x - center_x) // trapezoid_base_length) % 2 == 1
                    and ((y - center_y) // trapezoid_base_length) % 2 == 1
                )
                else -1
            )

            if (
                half_base_length - half_top_length
                <= x_relative
                <= half_base_length + half_top_length
                and half_base_length - half_top_length
                <= y_relative
                <= half_base_length + half_top_length
            ):
                # Flat top of the trapezoid
                ground[y, x] = trapezoid_height
            else:
                if x_relative < half_base_length - half_top_length:
                    # Sloped side of the trapezoid (ascending)
                    x_height = (
                        x_relative / (half_base_length - half_top_length)
                    ) * trapezoid_height
                elif x_relative < (half_base_length + half_top_length):
                    x_height = trapezoid_height
                else:
                    # Sloped side of the trapezoid (descending)
                    x_height = (
                        (trapezoid_base_length - x_relative)
                        / (half_base_length - half_top_length)
                    ) * trapezoid_height

                if y_relative < half_base_length - half_top_length:
                    # Sloped side of the trapezoid (ascending)
                    y_height = (
                        y_relative / (half_base_length - half_top_length)
                    ) * trapezoid_height
                elif y_relative < (half_base_length + half_top_length):
                    y_height = trapezoid_height
                else:
                    # Sloped side of the trapezoid (descending)
                    y_height = (
                        (trapezoid_base_length - y_relative)
                        / (half_base_length - half_top_length)
                    ) * trapezoid_height
                ground[y, x] = min(x_height, y_height)

            ground[y, x] *= phase

    return ground


def scale_terrain_height(
    min_height: float, max_height: float, terrain: np.ndarray
) -> np.ndarray:
    min_terrain, max_terrain = terrain.min(), terrain.max()
    return ((terrain - min_terrain) / (max_terrain - min_terrain)) * (
        max_height - min_height
    ) + min_height


def clear_terrain_center(
    terrain: np.ndarray, clear_radius: float, smooth_radius: float
) -> np.ndarray:
    y_size, x_size = terrain.shape
    x0 = x_size // 2
    y0 = y_size // 2

    # Create coordinate grids
    y_indices, x_indices = np.indices(terrain.shape)
    dist = np.sqrt((x_indices - x0) ** 2 + (y_indices - y0) ** 2)

    # Create masks
    clear_mask = dist <= clear_radius
    smooth_mask = (dist > clear_radius) & (dist <= clear_radius + smooth_radius)

    # Clear the center
    terrain[clear_mask] = 0

    # Pad the terrain to handle edges
    padded_terrain = np.pad(terrain, pad_width=1, mode="edge")

    # Initialize smoothed terrain
    smoothed_terrain = np.zeros_like(terrain)

    # Sum over the 3x3 neighborhood
    smoothed_terrain = (
        padded_terrain[0:-2, 0:-2]
        + padded_terrain[0:-2, 1:-1]
        + padded_terrain[0:-2, 2:]
        + padded_terrain[1:-1, 0:-2]
        + padded_terrain[1:-1, 1:-1]
        + padded_terrain[1:-1, 2:]
        + padded_terrain[2:, 0:-2]
        + padded_terrain[2:, 1:-1]
        + padded_terrain[2:, 2:]
    ) / 9.0

    # Replace values in the smooth_mask with the smoothed values
    terrain[smooth_mask] = smoothed_terrain[smooth_mask]

    return terrain


def generate_env_with_terrain(x_size: float, y_size: float, terrain: np.ndarray) -> str:
    """
    Format a 2D numpy array into a row-major order string with values separated by commas.

    Args:
        array (np.ndarray): The 2D numpy array to format.

    Returns:
        str: The formatted string in row-major order without a trailing comma.
    """
    ENV_TERRAIN_RSC = """
    <RSC Version="0.1">
        <Simulator>
            <Integration>
                <DtFrac>1</DtFrac>
            </Integration>
            <Damping>
                <InternalDampingZ>0.5</InternalDampingZ>
                <CollisionDampingZ>0.2</CollisionDampingZ>
                <GlobalDampingZ>0.03</GlobalDampingZ>
            </Damping>
            <RigidSolver>
                <RigidIterations>10</RigidIterations>
                <BaumgarteRatio>0.01</BaumgarteRatio>
            </RigidSolver>
            <Condition>
                <ResultStartCondition>
                    t >= 0
                </ResultStartCondition>
                <ResultStopCondition>
                    <![CDATA[
                        t >= 10
                    ]]>
                </ResultStopCondition>
                <StopCondition>
                    <![CDATA[
                        t >= 10
                    ]]>
                </StopCondition>
            </Condition>
            <Gravity>
                <GravAcc>-9.81</GravAcc>
                <FloorEnabled>1</FloorEnabled>
            </Gravity>
            <Signal>
                <ControlFrequency>10</ControlFrequency>
            </Signal>
            <FloorElevation>
                <X_Size>{}</X_Size>
                <Y_Size>{}</Y_Size>
                <X_Values>{}</X_Values>
                <Y_Values>{}</Y_Values>
                <Height>
                    {}
                </Height>
            </FloorElevation>
        </Simulator>
        <Voxel>
            <Size>0.01</Size>
            <Palette>
                <Material ID="1">
                    <Name>Body</Name>
                    <Display>
                        <Red>1</Red>
                        <Green>0</Green>
                        <Blue>0</Blue>
                        <Alpha>0.3</Alpha>
                    </Display>
                    <Mechanical>
                        <ElasticMod>3e4</ElasticMod>
                        <Density>800</Density>
                        <PoissonsRatio>0.35</PoissonsRatio>
                        <FrictionStatic>1</FrictionStatic>
                        <FrictionDynamic>0.8</FrictionDynamic>
                        <MaxExpansion>0.5</MaxExpansion>
                        <MinExpansion>-0.5</MinExpansion>
                    </Mechanical>
                </Material>
                <Material ID="2">
                    <Name>Body</Name>
                    <Display>
                        <Red>0</Red>
                        <Green>0</Green>
                        <Blue>1</Blue>
                        <Alpha>0.75</Alpha>
                    </Display>
                    <Mechanical>
                        <ElasticMod>3e4</ElasticMod>
                        <Density>1500</Density>
                        <PoissonsRatio>0.35</PoissonsRatio>
                        <FrictionStatic>1</FrictionStatic>
                        <FrictionDynamic>0.8</FrictionDynamic>
                        <MaxExpansion>0.5</MaxExpansion>
                        <MinExpansion>-0.5</MinExpansion>
                    </Mechanical>
                </Material>
            </Palette>
        </Voxel>
    </RSC>
    """
    # Flatten the terrain array in row-major order (C-style order)
    flattened_terrain = terrain.ravel(order="C")

    # Format the flattened array into a comma-separated string with values formatted as floating point
    terrain_string = ", ".join(f"{x:.2f}" for x in flattened_terrain)

    return ENV_TERRAIN_RSC.format(
        x_size, y_size, terrain.shape[1], terrain.shape[0], terrain_string
    )
